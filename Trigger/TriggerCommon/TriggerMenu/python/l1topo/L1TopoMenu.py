# Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration

from TopoOutput import TopoOutput
from AthenaCommon.Logging import logging
log = logging.getLogger("TriggerMenu.l1topo.L1TopoMenu")

class L1TopoMenu:

    def __init__(self, menuName):
        self.menuName = menuName
        # algorithms and their output location
        self.topoOutput = []

        self.globalConfig = dict()

    def __iter__(self):
        return self.topoOutput.__iter__()

    def __call__(self):
        return self.topoOutput
        
    def algoNames(self):
        return [x.algoname for x in self.topoOutput]         

    def __len__(self):
        return len(self.topoOutput)

    def addTopoLine(self, topoline):
        self.topoOutput += topoline

    def __iadd__(self, topoline):
        if topoline is not None:
            self.topoOutput += [ topoline ]
        return self

    def addGlobalConfig(self, name, value):
        self.globalConfig[name]=str(value)


    def getTriggerLines(self):
        from collections import namedtuple
        TriggerLine = namedtuple("TriggerLine","trigger cable bit clock fpga ordinal firstbit")
        outputLines = {}
        #print "Topo trigger defines %i output algorithms" % len(self.topoOutput)
        for output in self.topoOutput:

            for (idx,line) in enumerate(output.algo.outputs):
                
                ordinal = 64*output.module + 32*output.clock + 16*output.fpga + output.firstbit+idx

                outputLines[ordinal] = TriggerLine( trigger = line,
                                                    cable = output.module,
                                                    bit = output.firstbit+idx+16*output.fpga,
                                                    clock = output.clock,
                                                    fpga = output.fpga,
                                                    ordinal = ordinal,
                                                    firstbit = output.firstbit
                                                    )
        return [x[1] for x in sorted(outputLines.items())] # return the TriggerLines, sorted by the ordinal



    def xml(self, ind=1, step=2):
        s  = '<?xml version="1.0" ?>\n'
        s += '<TOPO_MENU menu_name="Topo_pp_vX" menu_version="1">\n' # % (self.menuName.replace("Physics_pp_","").replace("MC_pp_",""))
        s += '  <!--File is generated by TriggerMenu-->\n'
        s += '  <!--No. L1Topo algos defined: %i-->\n' % len(self.topoOutput)
        s += '  <OutputList>\n'
        for output in self.topoOutput:  # (Setup for module, fpga, firstbit, clock should be modified in more flexible way.)
            s += output.xml(ind+1,step)
        s += '  </OutputList>\n\n'
        s += '  <TopoConfig>\n'
        
        self.addGlobalConfig("global_em_scale", 2)
        self.addGlobalConfig("global_jet_scale", 1)
        
        for gPar in sorted(self.globalConfig.keys()):
            s += '    <Entry name="%s" value="%s"/>\n' % (gPar, self.globalConfig[gPar])
        s += '  </TopoConfig>\n\n'
        
        allSortAlgs = set()
        for output in self.topoOutput:
            allSortAlgs.update(output.sortingAlgos)
        for sortAlg in sorted(allSortAlgs):
            s += sortAlg.xml()+"\n"

        for output in self.topoOutput:
            s += output.algo.xml()+"\n"

        s += '</TOPO_MENU>\n'
        return s




    def readMenuFromXML(self,inputFile):
        from XMLMenuReader import readMenuFromXML
        readMenuFromXML(self, inputFile)

        
    def check(self):
        """
        All other checks should be implemented in TrigConfStorage/src/CheckConsistency.cxx

        This method is only for quick solutions but should be intermediate
        """

        idlist = [x.algo.algoId for x in self.topoOutput]
        if len(idlist)>0 and len(idlist) != max(idlist):
            idlist.sort()
            from itertools import groupby
            partition = [list(g) for k,g in groupby(enumerate(idlist), lambda (x,y) : y-x)]
            print "Algorithm IDs must start at 1 and be consecutive, but algorithm IDs are %s" % ','.join(["%i-%i" % (x[0][1],x[-1][1]) for x in partition])
            
            return False
        #sortedOutput = sorted(self.topoOutput,lambda x,y: cmp(x.algo.algoId,y.algo.algoId))
        #for trigger in sortedOutput:
        #    print trigger


        return True

