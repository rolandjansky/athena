#!/usr/bin/env python

def printObject(obj):
  if not obj: return
  print "Eta: %f Phi: %f pT: %f" % (obj.eta(), obj.phi(), obj.pt())

print 'Importing needed libraries...'
import ROOT

PoolAODInput=['/afs/cern.ch/user/b/bensmith/public/zmumu.AOD.pool.root']
print 'Building transient trees...'
from TrigDecisionTool.BuildTransientTrees import BuildTransientTrees
(transientTree, transientMetaDataTree) = BuildTransientTrees(PoolAODInput)

print 'Creating trig decision tool...'
trigDecisionTool = ROOT.Trig.TrigDecisionToolARA(transientTree, transientMetaDataTree)

print 'Creating matching tool...'
matchTool = ROOT.TrigMatchToolARA(trigDecisionTool)

numEntries = transientTree.GetEntries()
print 'Running on %i events...' % numEntries

for i in xrange(numEntries):

  print
  print "Reading event ", i
  transientTree.GetEntry(i)

  # load the muon collection
  muonCollection = transientTree.AtlfastMuonCollection

  # The basic idea is to loop through the reconstructed muons
  # and check which match to trigger muons and in which chains
  # We can control the level of the trigger we're matching to by
  # changing the type of the object we match to.  Here we match
  # to MuonFeature, which is generated by the L2 trigger.

  for muon in muonCollection:
    print
    print "Have reconstructed muon: ",
    printObject(muon)
    # find the chains in which the muon matches a trigger object 
    matchingChains = matchTool.chainsPassedByObject('MuonFeature')(muon)
    if len(matchingChains) > 0:
      for chain in matchingChains:
        # find the objects matched to the muon in that chain
        match = matchTool.matchToTriggerObject('MuonFeature')(muon, chain)
        print "Have matched trigger object from chain " + chain + ":",
        printObject(match)
      print
    else:
      print "Object does not match to trigger"
      print

  print 

