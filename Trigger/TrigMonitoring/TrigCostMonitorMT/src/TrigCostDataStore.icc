/*
  Copyright (C) 2002-2019 CERN for the benefit of the ATLAS collaboration
*/

#include "AthenaBaseComps/AthCheckMacros.h"

/////////////////////////////////////////////////////////////////////////////

template<typename PAYLOAD>
StatusCode TrigCostDataStore<PAYLOAD>::initialize(size_t nSlots) {
  m_store.resize( nSlots, tbb::concurrent_hash_map< AlgorithmIdentifier, PAYLOAD, AlgorithmIdentifierHashCompare>() );
  return StatusCode::SUCCESS;
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

template<typename PAYLOAD>
StatusCode TrigCostDataStore<PAYLOAD>::insert(const AlgorithmIdentifier& ai, const PAYLOAD& payload) {
  MsgStream& msg = *(ai.m_msg);
  const EventContext& context = *(ai.m_context);
  ATH_CHECK( checkSlot(context.slot(), msg) );
  tbb::concurrent_hash_map<AlgorithmIdentifier, PAYLOAD, AlgorithmIdentifierHashCompare>& mapReference = m_store.at( context.slot() );
  typename tbb::concurrent_hash_map< AlgorithmIdentifier, PAYLOAD, AlgorithmIdentifierHashCompare>::accessor acc;
  if (mapReference.insert(acc, ai)) {
    // Obtains lock on the key value 'name' until 'acc' goes out of scope or calls release()
    acc->second = payload;
  } else if (msg.level() <= MSG::WARNING) {
    msg << MSG::WARNING << "Key caller:'" << ai.m_caller << "' store:'" << ai.m_store << "' already in the TrigCostDataStore" << endmsg; 
  }
  return StatusCode::SUCCESS;
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

template<typename PAYLOAD>
StatusCode TrigCostDataStore<PAYLOAD>::retrieve(const AlgorithmIdentifier& ai, PAYLOAD& payload) const {
  MsgStream& msg = *(ai.m_msg);
  const EventContext& context = *(ai.m_context);
  ATH_CHECK( checkSlot(context.slot(), msg) );
  const tbb::concurrent_hash_map< AlgorithmIdentifier, PAYLOAD, AlgorithmIdentifierHashCompare>& mapReference = m_store.at( context.slot() );
  typename tbb::concurrent_hash_map<AlgorithmIdentifier, PAYLOAD, AlgorithmIdentifierHashCompare>::const_accessor cacc; // Does not lock other const_accessor
  if (!mapReference.find(cacc, ai)) {
    if (msg.level() <= MSG::DEBUG) {
      msg << MSG::DEBUG << "Cannot access key caller:'" << ai.m_caller << "' store:'" << ai.m_store << "' from the the TrigCostDataStore" << endmsg;
    }
    return StatusCode::FAILURE;
  }
  payload = cacc->second;
  return StatusCode::SUCCESS; 
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

template<typename PAYLOAD>
StatusCode TrigCostDataStore<PAYLOAD>::clear(const EventContext& context, MsgStream& msg) {
  ATH_CHECK( checkSlot(context.slot(), msg) );
  tbb::concurrent_hash_map<AlgorithmIdentifier, PAYLOAD, AlgorithmIdentifierHashCompare>& mapReference = m_store.at( context.slot() );
  mapReference.clear();
  if (msg.level() <= MSG::DEBUG) msg << MSG::DEBUG << "Clearing slot " << context.slot() << endmsg;
  return StatusCode::SUCCESS;  
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

template<typename PAYLOAD>
StatusCode TrigCostDataStore<PAYLOAD>::getIterators(const EventContext& context, MsgStream& msg, 
  typename tbb::concurrent_hash_map<AlgorithmIdentifier, PAYLOAD, AlgorithmIdentifierHashCompare>::const_iterator& begin, 
  typename tbb::concurrent_hash_map<AlgorithmIdentifier, PAYLOAD, AlgorithmIdentifierHashCompare>::const_iterator& end) {
  ATH_CHECK( checkSlot(context.slot(), msg) );
  const tbb::concurrent_hash_map<AlgorithmIdentifier, PAYLOAD, AlgorithmIdentifierHashCompare>& mapReference = m_store.at( context.slot() );
  begin = mapReference.begin();
  end = mapReference.end();
  return StatusCode::SUCCESS;
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

template<typename PAYLOAD>
StatusCode TrigCostDataStore<PAYLOAD>::checkSlot(const size_t slot, MsgStream& msg) const {
  if (m_store.size() <= slot) {
    msg << MSG::FATAL << "Requesting slot " << slot << " but we only reserved for " << m_store.size() << " slots. Make sure setSlots() was called." << endmsg;
    return StatusCode::FAILURE;
  }
  return StatusCode::SUCCESS;
}

