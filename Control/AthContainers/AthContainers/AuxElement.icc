// Dear emacs, this is -*- c++ -*-

/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// $Id: AuxElement.icc 627952 2014-11-12 17:27:57Z ssnyder $
/**
 * @file AthContainers/AuxElement.icc
 * @author scott snyder <snyder@bnl.gov>
 * @date Sep, 2013
 * @brief Base class for elements of a container that can have aux data.
 */


#include "AthContainers/tools/likely.h"
#include <cassert>


namespace SG {


/**
 * @brief Default constructor.
 */
inline
AuxElement::AuxElement() 
  : m_index(0),
    m_container(0),
    m_privateData(0)
{
}


/**
 * @brief Constructor with explicit container / index.
 * @param container Container of which this element will be a part.
 * @param index Index of this element within the container.
 *
 * This does not make any changes to aux data.
 */
inline
AuxElement::AuxElement (SG::AuxVectorData* container,
                        size_t index)
  : m_index(index),
    m_container (container),
    m_privateData(0)
{
}


/**
 * @brief Copy Constructor.
 * @param other Object being copied.
 *
 * We do not copy the container/index --- the new object is not yet
 * in a container!
 *
 * In the case of constructing an object with a private store,
 * @c makePrivateStore will take care of copying the aux data.
 */
inline
AuxElement::AuxElement (const AuxElement& /*other*/)
  : m_index(0),
    m_container(0),
    m_privateData(0)
{
}


/**
 * @brief Assignment.
 * @param other The object from which we're assigning.
 *
 * We don't copy container/index, as assignment doesn't change where
 * this object is.  However, if we have aux data, then we copy aux data
 * if we're copying from an object that also has it; otherwise,
 * if we're copying from an object with no aux data, then we clear ours.
 */
inline
AuxElement& AuxElement::operator= (const AuxElement& other)
{
  if (this != &other) {
    if (this->container()) {
      if (!other.container()) {
        // Copying from an object with no aux data.
        // Clear our aux data.
        this->clearAux();
      }
      else {
        // Copying from an object with aux data.
        // Copy the aux data too.
        this->copyAux (other);
      }
    }
  }
  return *this;
}


/**
 * @brief Destructor.
 *
 * Any private store is deleted.
 */
inline
AuxElement::~AuxElement()
{
  if (ATHCONTAINERS_UNLIKELY (m_privateData))
    releasePrivateStoreForDtor();
}


/**
 * @brief Return the container holding this element.
 */
inline
SG::AuxVectorData* AuxElement::container()
{
  return m_container;
}


/**
 * @brief Return the container holding this element.
 */
inline
const SG::AuxVectorData* AuxElement::container() const
{
  return m_container;
}


/**
 * @brief Return the index of this element within its container.
 */
inline
size_t AuxElement::index() const
{
  return m_index;
}


//******************************************************************************


/**
 * @brief Constructor.
 * @param name Name of this aux variable.
 *
 * The name -> auxid lookup is done here.
 */
inline
AuxElement::TypelessConstAccessor::TypelessConstAccessor (const std::string& name)
{
  SG::AuxTypeRegistry& r = SG::AuxTypeRegistry::instance();
  m_auxid = r.findAuxID(name);
  if (m_auxid == null_auxid)
    SG::throwExcUnknownAuxItem (name);
  m_eltSize = r.getEltSize (m_auxid);
}


/**
 * @brief Constructor.
 * @param ti The type for this aux data item.
 * @param name Name of this aux variable.
 *
 * The name -> auxid lookup is done here.
 */
inline
AuxElement::TypelessConstAccessor::TypelessConstAccessor (const std::type_info& ti,
                                                          const std::string& name)
{
  SG::AuxTypeRegistry& r = SG::AuxTypeRegistry::instance();
  m_auxid = r.getAuxID (ti, name);
  if (m_auxid == null_auxid)
    SG::throwExcUnknownAuxItem (name, "", &ti);
  m_eltSize = r.getEltSize (m_auxid);
}


/**
 * @brief Constructor.
 * @param name Name of this aux variable.
 * @param clsname The name of its associated class.  May be blank.
 *
 * The name -> auxid lookup is done here.
 */
inline
AuxElement::TypelessConstAccessor::TypelessConstAccessor (const std::string& name,
                                                          const std::string& clsname)
{
  SG::AuxTypeRegistry& r = SG::AuxTypeRegistry::instance();
  m_auxid = r.findAuxID(name, clsname);
  if (m_auxid == null_auxid)
    SG::throwExcUnknownAuxItem (name, clsname);
  m_eltSize = r.getEltSize (m_auxid);
}


/**
 * @brief Constructor.
 * @param ti The type for this aux data item.
 * @param name Name of this aux variable.
 * @param clsname The name of its associated class.  May be blank.
 *
 * The name -> auxid lookup is done here.
 */
inline
AuxElement::TypelessConstAccessor::TypelessConstAccessor (const std::type_info& ti,
                                                          const std::string& name,
                                                          const std::string& clsname)
{
  SG::AuxTypeRegistry& r = SG::AuxTypeRegistry::instance();
  m_auxid = r.getAuxID (ti, name, clsname);
  if (m_auxid == null_auxid)
    SG::throwExcUnknownAuxItem (name, clsname, &ti);
  m_eltSize = r.getEltSize (m_auxid);
}


/**
 * @brief Fetch the variable for one element, as a const pointer.
 * @param e The element for which to fetch the variable.
 */
inline
const void*
AuxElement::TypelessConstAccessor::operator() (const AuxElement& e) const
{
  assert (e.container() != 0);
  return (*this) (*e.container(), e.m_index);
}


/**
 * @brief Fetch the variable for one element, as a const pointer.
 * @param container The container from which to fetch the variable.
 * @param index The index of the desired element.
 *
 * This allows retrieving aux data by container / index.
 * Looping over the index via this method will be faster then
 * looping over the elements of the container.
 */
inline
const void*
AuxElement::TypelessConstAccessor::operator() (const AuxVectorData& container,
                                               size_t index) const
{
  const char* ptr = reinterpret_cast<const char*> (getDataArray (container));
  return ptr + index * m_eltSize;
}

    
/**
 * @brief Get a pointer to the start of the auxiliary data array.
 * @param container The container from which to fetch the variable.
 */
inline
const void*
AuxElement::TypelessConstAccessor::getDataArray (const AuxVectorData& container) const
{
  return container.getDataArray (m_auxid);
}
    

/**
 * @brief Test to see if this variable exists in the store.
 * @param e An element of the container which to test the variable.
 */
inline
bool
AuxElement::TypelessConstAccessor::isAvailable (const AuxElement& e) const
{
  return e.container() && e.container()->isAvailable (m_auxid);
}


/**
 * @brief Return the aux id for this variable.
 */
inline
SG::auxid_t
AuxElement::TypelessConstAccessor::auxid() const
{
  return m_auxid;
}


//******************************************************************************


/**
 * @brief Constructor.
 * @param name Name of this aux variable.
 *
 * The name -> auxid lookup is done here.
 */
template <class T>
inline
AuxElement::ConstAccessor<T>::ConstAccessor (const std::string& name)
  : m_auxid (SG::AuxTypeRegistry::instance().getAuxID<T> (name))
{
}


/**
 * @brief Constructor.
 * @param name Name of this aux variable.
 * @param clsname The name of its associated class.  May be blank.
 *
 * The name -> auxid lookup is done here.
 */
template <class T>
inline
AuxElement::ConstAccessor<T>::ConstAccessor (const std::string& name,
                                             const std::string& clsname)
  : m_auxid (SG::AuxTypeRegistry::instance().getAuxID<T> (name, clsname))
{
}


/**
 * @brief Fetch the variable for one element, as a const reference.
 * @param e The element for which to fetch the variable.
 */
template <class T>
inline
typename AuxElement::ConstAccessor<T>::const_reference_type
AuxElement::ConstAccessor<T>::operator() (const AuxElement& e) const
{
  assert (e.container() != 0);
  return e.container()->template getData<T> (m_auxid, e.m_index);
}


/**
 * @brief Fetch the variable for one element, as a const reference.
 * @param container The container from which to fetch the variable.
 * @param index The index of the desired element.
 *
 * This allows retrieving aux data by container / index.
 * Looping over the index via this method will be faster then
 * looping over the elements of the container.
 */
template <class T>
inline
typename AuxElement::ConstAccessor<T>::const_reference_type
AuxElement::ConstAccessor<T>::operator() (const AuxVectorData& container,
                                          size_t index) const
{
  return container.template getData<T> (m_auxid, index);
}



/**
 * @brief Get a pointer to the start of the auxiliary data array.
 * @param container The container from which to fetch the variable.
 */
template <class T>
inline
typename AuxElement::ConstAccessor<T>::const_container_pointer_type
AuxElement::ConstAccessor<T>::getDataArray (const AuxVectorData& container) const
{
  return reinterpret_cast<const_container_pointer_type>
    (container.getDataArray (m_auxid));
}
    

/**
 * @brief Test to see if this variable exists in the store.
 * @param e An element of the container which to test the variable.
 */
template <class T>
inline
bool
AuxElement::ConstAccessor<T>::isAvailable (const AuxElement& e) const
{
  return e.container() && e.container()->isAvailable (m_auxid);
}


/**
 * @brief Return the aux id for this variable.
 */
template <class T>
inline
SG::auxid_t
AuxElement::ConstAccessor<T>::auxid() const
{
  return m_auxid;
}


//******************************************************************************


/**
 * @brief Constructor.
 * @param name Name of this aux variable.
 *
 * The name -> auxid lookup is done here.
 */
template <class T>
inline
AuxElement::Accessor<T>::Accessor (const std::string& name)
  : ConstAccessor<T> (name)
{
}


/**
 * @brief Constructor.
 * @param name Name of this aux variable.
 * @param clsname The name of its associated class.  May be blank.
 *
 * The name -> auxid lookup is done here.
 */
template <class T>
inline
AuxElement::Accessor<T>::Accessor (const std::string& name,
                                   const std::string& clsname)
  : ConstAccessor<T> (name, clsname)
{
}


/**
 * @brief Fetch the variable for one element, as a non-const reference.
 * @param e The element for which to fetch the variable.
 */
template <class T>
inline
typename AuxElement::Accessor<T>::reference_type
AuxElement::Accessor<T>::operator() (AuxElement& e) const
{
  assert (e.container() != 0);
  return e.container()->template getData<T> (this->m_auxid, e.m_index);
}


/**
 * @brief Fetch the variable for one element, as a non-const reference.
 * @param container The container from which to fetch the variable.
 * @param index The index of the desired element.
 *
 * This allows retrieving aux data by container / index.
 * Looping over the index via this method will be faster then
 * looping over the elements of the container.
 */
template <class T>
inline
typename AuxElement::Accessor<T>::reference_type
AuxElement::Accessor<T>::operator() (AuxVectorData& container,
                                     size_t index) const
{
  return container.template getData<T> (this->m_auxid, index);
}


/**
 * @brief Set the variable for one element.
 * @param e The element for which to fetch the variable.
 * @param x The variable value to set.
 */
template <class T>
inline
void AuxElement::Accessor<T>::set (AuxElement& e, const element_type& x) const
{
  (*this)(e) = x;
}


/**
 * @brief Get a pointer to the start of the auxiliary data array.
 * @param container The container from which to fetch the variable.
 */
template <class T>
inline
typename AuxElement::Accessor<T>::container_pointer_type
AuxElement::Accessor<T>::getDataArray (AuxVectorData& container) const
{
  return reinterpret_cast<container_pointer_type>
    (container.getDataArray (this->m_auxid));
}


/**
 * @brief Test to see if this variable exists in the store and is writable.
 * @param e An element of the container which to test the variable.
 */
template <class T>
inline
bool
AuxElement::Accessor<T>::isAvailableWritable (AuxElement& e) const
{
  return e.container() && e.container()->isAvailableWritable (this->m_auxid);
}


//******************************************************************************


/**
 * @brief Constructor.
 * @param name Name of this aux variable.
 *
 * The name -> auxid lookup is done here.
 */
template <class T>
inline
AuxElement::Decorator<T>::Decorator (const std::string& name)
  : m_auxid (SG::AuxTypeRegistry::instance().getAuxID<T> (name))
{
}


/**
 * @brief Constructor.
 * @param name Name of this aux variable.
 * @param clsname The name of its associated class.  May be blank.
 *
 * The name -> auxid lookup is done here.
 */
template <class T>
inline
AuxElement::Decorator<T>::Decorator (const std::string& name,
                                     const std::string& clsname)
  : m_auxid (SG::AuxTypeRegistry::instance().getAuxID<T> (name, clsname))
{
}


/**
 * @brief Fetch the variable for one element, as a non-const reference.
 * @param e The element for which to fetch the variable.
 *
 * If the container is locked, this will allow fetching only variables
 * that do not yet exist (in which case they will be marked as decorations)
 * or variables already marked as decorations.
 */
template <class T>
inline
typename AuxElement::Decorator<T>::reference_type
AuxElement::Decorator<T>::operator() (const AuxElement& e) const
{
  assert (e.container() != 0);
  return e.container()->template getDecoration<T> (m_auxid, e.m_index);
}


/**
 * @brief Fetch the variable for one element, as a non-const reference.
 * @param container The container from which to fetch the variable.
 * @param index The index of the desired element.
 *
 * This allows retrieving aux data by container / index.
 * Looping over the index via this method will be faster then
 * looping over the elements of the container.
 *
 * If the container is locked, this will allow fetching only variables
 * that do not yet exist (in which case they will be marked as decorations)
 * or variables already marked as decorations.
 */
template <class T>
inline
typename AuxElement::Decorator<T>::reference_type
AuxElement::Decorator<T>::operator() (const AuxVectorData& container,
                                      size_t index) const
{
  return container.template getDecoration<T> (m_auxid, index);
}


/**
 * @brief Set the variable for one element.
 * @param e The element for which to fetch the variable.
 * @param x The variable value to set.
 */
template <class T>
inline
void AuxElement::Decorator<T>::set (const AuxElement& e,
                                    const element_type& x) const
{
  (*this)(e) = x;
}


/**
 * @brief Get a pointer to the start of the auxiliary data array.
 * @param container The container from which to fetch the variable.
 */
template <class T>
inline
typename AuxElement::Decorator<T>::const_container_pointer_type
AuxElement::Decorator<T>::getDataArray (const AuxVectorData& container) const
{
  return reinterpret_cast<const_container_pointer_type>
    (container.getDataArray (m_auxid));
}


/**
 * @brief Get a pointer to the start of the auxiliary data array.
 * @param container The container from which to fetch the variable.
 *
 * If the container is locked, this will allow fetching only variables
 * that do not yet exist (in which case they will be marked as decorations)
 * or variables already marked as decorations.
 */
template <class T>
inline
typename AuxElement::Decorator<T>::container_pointer_type
AuxElement::Decorator<T>::getDecorationArray (const AuxVectorData& container) const
{
  return reinterpret_cast<container_pointer_type>
    (container.getDecorationArray (m_auxid));
}


/**
 * @brief Test to see if this variable exists in the store.
 * @param e An element of the container which to test the variable.
 */
template <class T>
inline
bool
AuxElement::Decorator<T>::isAvailable (const AuxElement& e) const
{
  return e.container() && e.container()->isAvailable (m_auxid);
}


/**
 * @brief Test to see if this variable exists in the store and is writable.
 * @param e An element of the container which to test the variable.
 */
template <class T>
inline
bool
AuxElement::Decorator<T>::isAvailableWritable (const AuxElement& e) const
{
  return e.container() && e.container()->isAvailableWritableAsDecoration (m_auxid);
}


/**
 * @brief Return the aux id for this variable.
 */
template <class T>
inline
SG::auxid_t
AuxElement::Decorator<T>::auxid() const
{
  return m_auxid;
}


//******************************************************************************


/**
 * @brief Fetch an aux data variable, as a non-const reference.
 * @param name Name of the aux variable.
 * @param clsname The name of the associated class.  May be blank.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c Accessor
 * class above.
 */
template <class T>
typename AuxDataTraits<T>::reference_type
AuxElement::auxdata (const std::string& name)
{
  return Accessor<T>(name, "")(*this);
}


/**
 * @brief Fetch an aux data variable, as a non-const reference.
 * @param name Name of the aux variable.
 * @param clsname The name of the associated class.  May be blank.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c Accessor
 * class above.
 */
template <class T>
typename AuxDataTraits<T>::reference_type
AuxElement::auxdata (const std::string& name,
                     const std::string& clsname)
{
  return Accessor<T>(name, clsname)(*this);
}


/**
 * @brief Fetch an aux data variable, as a const reference.
 * @param name Name of the aux variable.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c Accessor
 * or @c ConstAccessor classes above.
 */
template <class T>
typename AuxDataTraits<T>::const_reference_type
AuxElement::auxdata (const std::string& name) const
{
  return Accessor<T>(name, "")(*this);
}


/**
 * @brief Fetch an aux data variable, as a const reference.
 * @param name Name of the aux variable.
 * @param clsname The name of the associated class.  May be blank.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c Accessor
 * or @c ConstAccessor classes above.
 */
template <class T>
typename AuxDataTraits<T>::const_reference_type
AuxElement::auxdata (const std::string& name,
                     const std::string& clsname) const
{
  return Accessor<T>(name, clsname)(*this);
}


/**
 * @brief Fetch an aux data variable, as a const reference.
 * @param name Name of the aux variable.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c ConstAccessor
 * class above.
 */
template <class T>
typename AuxDataTraits<T>::const_reference_type
AuxElement::auxdataConst (const std::string& name) const
{
  return Accessor<T>(name, "")(*this);
}


/**
 * @brief Fetch an aux data variable, as a const reference.
 * @param name Name of the aux variable.
 * @param clsname The name of the associated class.  May be blank.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c ConstAccessor
 * class above.
 */
template <class T>
typename AuxDataTraits<T>::const_reference_type
AuxElement::auxdataConst (const std::string& name,
                          const std::string& clsname) const
{
  return Accessor<T>(name, clsname)(*this);
}


/**
 * @brief Check if an aux variable is available for reading
 * @param name Name of the aux variable.
 * @param clsname The name of the associated class.  May be blank.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c Accessor
 * class above.
 */
template <class T>
bool AuxElement::isAvailable (const std::string& name,
                              const std::string& clsname /*= ""*/) const
{
  return Accessor<T>(name, clsname).isAvailable(*this);
}


/**
 * @brief Check if an aux variable is available for writing
 * @param name Name of the aux variable.
 * @param clsname The name of the associated class.  May be blank.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c Accessor
 * class above.
 */
template <class T>
bool AuxElement::isAvailableWritable (const std::string& name,
                                      const std::string& clsname /*= ""*/)
{
  return Accessor<T>(name, clsname).isAvailableWritable(*this);
}


/**
 * @brief Check if an aux variable is available for writing as a decoration.
 * @param name Name of the aux variable.
 * @param clsname The name of the associated class.  May be blank.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c Accessor
 * class above.
 */
template <class T>
bool AuxElement::isAvailableWritableAsDecoration (const std::string& name,
                                                  const std::string& clsname /*= ""*/) const
{
  return Decorator<T>(name, clsname).isAvailableWritable(*this);
}


/**
 * @brief Fetch an aux decoration, as a non-const reference.
 * @param name Name of the aux variable.
 * @param clsname The name of the associated class.  May be blank.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c Accessor
 * class above.
 *
 * If the container is locked, this will allow fetching only variables
 * that do not yet exist (in which case they will be marked as decorations)
 * or variables already marked as decorations.
 */
template <class T>
typename AuxDataTraits<T>::reference_type
AuxElement::auxdecor (const std::string& name) const
{
  return Decorator<T>(name, "")(*this);
}


/**
 * @brief Fetch an aux decoration, as a non-const reference.
 * @param name Name of the aux variable.
 * @param clsname The name of the associated class.  May be blank.
 *
 * This method has to translate from the aux data name to the internal
 * representation each time it is called.  Using this method
 * inside of loops is discouraged; instead use the @c Accessor
 * class above.
 *
 * If the container is locked, this will allow fetching only variables
 * that do not yet exist (in which case they will be marked as decorations)
 * or variables already marked as decorations.
 */
template <class T>
typename AuxDataTraits<T>::reference_type
AuxElement::auxdecor (const std::string& name,
                      const std::string& clsname) const
{
  return Decorator<T>(name, clsname)(*this);
}


/**
 * @brief Create a new private store for this object and copy aux data.
 * @param other The object from which aux data should be copied.
 *
 * @c ExcBadPrivateStore will be thrown if this object is already
 * associated with a store.
 *
 * If @c other is an object that has aux data, then those data will
 * be copied; otherwise, nothing will be done.
 */
template <class U1>
inline
void AuxElement::makePrivateStore (const U1& other)
{
  // Dispatch to the proper overload depending on whether or not
  // other derives from AuxElement.
  makePrivateStore1 (&other);
}


/**
 * @brief Create a new private store for this object and copy aux data.
 * @param other The object from which aux data should be copied.
 *
 * @c ExcBadPrivateStore will be thrown if this object is already
 * associated with a store.
 *
 * If @c other is an object that has aux data, then those data will
 * be copied; otherwise, nothing will be done.
 */
template <class U1>
inline
void AuxElement::makePrivateStore (const U1* other)
{
  // Dispatch to the proper overload depending on whether or not
  // other derives from AuxElement.
  makePrivateStore1 (other);
}


/**
 * @brief Synonym for @c setStore with @c IConstAuxStore.
 * @param store The new store.
 */
inline
void AuxElement::setConstStore (const SG::IConstAuxStore* store)
{
  setStore (store);
}


/**
 * @brief Synonym for @c setStore with @c IAuxStore.
 * @param store The new store.
 */
inline
void AuxElement::setNonConstStore (SG::IAuxStore* store)
{
  setStore (store);
}


/**
 * @brief Set the index/container for this element.
 * @param index The index of this object within the container.
 * @param container The container holding this object.
 *                  May be null if this object is being removed
 *                  from a container.
 *
 * Usually this simply sets the index and container members
 * of this object.  However, in the case where this object has
 * an associated private store, then we need to deal with
 * releasing the store if the object is being added to a container,
 * or making a new store if the object is being removed from a container.
 */
inline
void AuxElement::setIndex (size_t index, SG::AuxVectorData* container)
{
  if (ATHCONTAINERS_UNLIKELY (m_privateData != 0)) {
    // out-of-line piece, dealing with private store.
    setIndexPrivate (index, container);
    return;
  }

  m_index = index;
  m_container = container;
}


/**
 * @brief Create a new private store for this object and copy aux data.
 * @param other The object from which aux data should be copied.
 *
 * @c ExcBadPrivateStore will be thrown if this object is already
 * associated with a store.
 *
 * This overload handles the case where @c other does not have aux data.
 */
inline
void AuxElement::makePrivateStore1 (const void*)
{
  makePrivateStore();
}


/**
 * @brief Helper to test if m_privateData is valid.
 */
inline
bool AuxElement::privateDataValid() const
{
  return m_privateData != 0 && m_privateData != s_privatePlaceholder;
}


} // namespace SG
