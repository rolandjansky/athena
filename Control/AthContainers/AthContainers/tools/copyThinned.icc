/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// $Id$
/**
 * @file AthContainers/tools/copyThinned.icc
 * @author scott snyder <snyder@bnl.gov>
 * @date Jul, 2014
 * @brief Helper to copy an object while applying thinning.
 */


namespace SG {


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dummy Dummy argument for overload resolution.
 * @param svc The thinning service.
 *
 * This is the generic version of @c copyThinned, which matches types
 * for which there is not a more specific overload.  It simply makes
 * a copy of @c orig using the copy constructor.
 */
template <class CONTAINER>
CONTAINER*
copyThinned1 (const CONTAINER& orig,
              const void* /*dummy*/,
              IThinningSvc* /*svc*/)
{
  return new CONTAINER (orig);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dummy Dummy argument for overload resolution.
 * @param svc The thinning service.
 *
 * This overload handles @c DataVector types.  It returns a view container
 * copy of @c orig, from which any thinned elements are removed.
 */
template <class CONTAINER>
const CONTAINER*
copyThinned1 (const CONTAINER& orig,
              const DataVector<typename CONTAINER::base_value_type>* /*dummy*/,
              IThinningSvc* svc)
{
  size_t size = orig.size();
  if (size > 0 &&
      svc &&
      svc->thinningOccurred (&orig))
  {
    ConstDataVector<CONTAINER>* newcont = new ConstDataVector<CONTAINER>;
    newcont->clear (SG::VIEW_ELEMENTS);
    newcont->reserve (size);

    for (size_t i = 0; i < size; i++) {
      if (!IThinningSvc::isThinned (svc->index (&orig, i))) {
        newcont->push_back (orig[i]);
      }
    }
    
    return newcont->asDataVector();
  }

  return new CONTAINER (orig);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dummy Dummy argument for overload resolution.
 * @param svc The thinning service.
 *
 * This overload handles @c IAuxStore types.  It returns a new copy
 * of the store, with any thinned elements removed.
 */
template <class CONTAINER>
CONTAINER*
copyThinned1 (const CONTAINER& orig,
              const SG::IAuxStore* /*dummy*/,
              IThinningSvc* svc)
{
  // T->P conversion is done from within copyAuxStoreThinned,
  // so we need to call it regardless of whether or not
  // thinning is actually done.  Don't call it though if the
  // container is empty.
  if (orig.size() > 0)
  {
    CONTAINER* newcont = new CONTAINER;
    copyAuxStoreThinned (orig, *newcont, svc);
    return newcont;
  }

  return new CONTAINER (orig);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param svc The thinning service.
 *
 * Returns a new copy of @c orig with elements removed according to the
 * thinning defined in @c svc.  Ownership of the new object is passed
 * back to the caller.
 *
 * The code here handles @c IAuxStore objects.
 * (For a @c DataVector object, use @c copyThinnedConst.)
 * Support for additional object types may be added by adding
 * overloads for @c copyThinned1.
 */
template <class CONTAINER>
CONTAINER* copyThinned (const CONTAINER& orig,
                        IThinningSvc* svc)
{
  return copyThinned1 (orig, &orig, svc);
}


/**
 * @brief Helper to copy an object while applying thinning, const version.
 * @param orig The object to copy.
 * @param svc The thinning service.
 *
 * Returns a new copy of @c orig with elements removed according to the
 * thinning defined in @c svc.  Ownership of the new object is passed
 * back to the caller.
 *
 * The code here handles @c DataVector and @c IAuxStore objects.
 * Support for additional object types may be added by adding
 * overloads for @c copyThinned1.
 */
template <class CONTAINER>
const CONTAINER* copyThinnedConst (const CONTAINER& orig,
                                   IThinningSvc* svc)
{
  return copyThinned1 (orig, &orig, svc);
}


} // namespace SG
