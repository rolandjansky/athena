/*
  Copyright (C) 2002-2019 CERN for the benefit of the ATLAS collaboration
*/

/**
 * @file AthContainers/tools/copyThinned.icc
 * @author scott snyder <snyder@bnl.gov>
 * @date Jul, 2014
 * @brief Helper to copy an object while applying thinning.
 */


namespace SG {


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dummy Dummy argument for overload resolution.
 * @param svc The thinning service.
 *
 * This is the generic version of @c copyThinned, which matches types
 * for which there is not a more specific overload.  It simply makes
 * a copy of @c orig using the copy constructor.
 *
 * [To be removed as part of MT thinning work; use the variant below instead.]
 */
template <class CONTAINER>
CONTAINER*
copyThinned1 (const CONTAINER& orig,
              const void* /*dummy*/,
              IThinningSvc* /*svc*/)
{
  return new CONTAINER (orig);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dummy Dummy argument for overload resolution.
 * @param svc The thinning service.
 *
 * This overload handles @c DataVector types.  It returns a view container
 * copy of @c orig, from which any thinned elements are removed.
 */
template <class CONTAINER>
std::unique_ptr<CONTAINER>
copyThinned1 (const CONTAINER& orig,
              const void* /*dummy*/,
              const SG::ThinningDecisionBase* /*dec*/)
{
  return std::make_unique<CONTAINER> (orig);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dummy Dummy argument for overload resolution.
 * @param svc The thinning service.
 *
 * This overload handles @c DataVector types.  It returns a view container
 * copy of @c orig, from which any thinned elements are removed.
 *
 * [To be removed as part of MT thinning work; use the variant below instead.]
 */
template <class CONTAINER>
const CONTAINER*
copyThinned1 (const CONTAINER& orig,
              const DataVector<typename CONTAINER::base_value_type>* /*dummy*/,
              IThinningSvc* svc)
{
  size_t size = orig.size();
  if (size > 0 &&
      svc &&
      svc->thinningOccurred (&orig))
  {
    ConstDataVector<CONTAINER>* newcont = new ConstDataVector<CONTAINER>;
    newcont->clear (SG::VIEW_ELEMENTS);
    newcont->reserve (size);

    for (size_t i = 0; i < size; i++) {
      if (!IThinningSvc::isThinned (svc->index (&orig, i))) {
        newcont->push_back (orig[i]);
      }
    }
    
    return newcont->asDataVector();
  }

  return new CONTAINER (orig);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dummy Dummy argument for overload resolution.
 * @param dec The thinning decision for this object.
 *
 * This overload handles @c DataVector types.  It returns a view container
 * copy of @c orig, from which any thinned elements are removed.
 */
template <class CONTAINER>
std::unique_ptr<CONTAINER>
copyThinned1 (CONTAINER& orig,
              DataVector<typename CONTAINER::base_value_type>* /*dummy*/,
              const SG::ThinningDecisionBase* dec)
{
  IThinningSvc* svc = IThinningSvc::instance();
  size_t size = orig.size();
  if (size > 0 && (dec || (svc && svc->thinningOccurred(&orig))))
  {
    auto newcont = std::make_unique<CONTAINER>();
    newcont->clear (SG::VIEW_ELEMENTS);
    newcont->reserve (size);

    for (size_t i = 0; i < size; i++) {
      if (!(dec && dec->thinned (i)) &&
          !(svc && IThinningSvc::isThinned (svc->index (&orig, i))))
      {
        newcont->push_back (orig[i]);
      }
    }
    
    return newcont;
  }

  return std::make_unique<CONTAINER> (orig);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dummy Dummy argument for overload resolution.
 * @param dec The thinning decision for this object.
 *
 * This overload handles @c DataVector types.  It returns a view container
 * copy of @c orig, from which any thinned elements are removed.
 */
template <class CONTAINER>
std::unique_ptr<const CONTAINER>
copyThinned1 (const CONTAINER& orig,
              const DataVector<typename CONTAINER::base_value_type>* /*dummy*/,
              const SG::ThinningDecisionBase* dec)
{
  IThinningSvc* svc = IThinningSvc::instance();
  size_t size = orig.size();
  if (size > 0 && (dec || (svc && svc->thinningOccurred(&orig))))
  {
    auto newcont = std::make_unique<ConstDataVector<CONTAINER> >();
    newcont->clear (SG::VIEW_ELEMENTS);
    newcont->reserve (size);

    for (size_t i = 0; i < size; i++) {
      if (!(dec && dec->thinned (i)) &&
          !(svc && IThinningSvc::isThinned (svc->index (&orig, i))))
      {
        newcont->push_back (orig[i]);
      }
    }
    
    return std::unique_ptr<const CONTAINER>(newcont.release()->asDataVector());
  }

  return std::make_unique<CONTAINER> (orig);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dummy Dummy argument for overload resolution.
 * @param svc The thinning service.
 *
 * This overload handles @c IAuxStore types.  It returns a new copy
 * of the store, with any thinned elements removed.
 *
 * [To be removed as part of MT thinning work; use the variant below instead.]
 */
template <class CONTAINER>
CONTAINER*
copyThinned1 (const CONTAINER& orig,
              const SG::IAuxStore* /*dummy*/,
              IThinningSvc* svc)
{
  // T->P conversion is done from within copyAuxStoreThinned,
  // so we need to call it regardless of whether or not
  // thinning is actually done.  Don't call it though if the
  // container is empty.
  // We need the cast because some aux store classes define `size'
  // as a member :(.
  if (static_cast<const SG::IConstAuxStore&>(orig).size() > 0)
  {
    CONTAINER* newcont = new CONTAINER;
    copyAuxStoreThinned (orig, *newcont, svc);
    return newcont;
  }

  return new CONTAINER (orig);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dummy Dummy argument for overload resolution.
 * @param dec The thinning decision for this object.
 *
 * This overload handles @c IAuxStore types.  It returns a new copy
 * of the store, with any thinned elements removed.
 */
template <class CONTAINER>
std::unique_ptr<CONTAINER>
copyThinned1 (const CONTAINER& orig,
              const SG::IAuxStore* /*dummy*/,
              const SG::ThinningDecisionBase* dec)
{
  // T->P conversion is done from within copyAuxStoreThinned,
  // so we need to call it regardless of whether or not
  // thinning is actually done.  Don't call it though if the
  // container is empty.
  // The cast is needed because some xAOD aux store classes
  // declare a data member `size'.
  if (static_cast<const SG::IAuxStore&>(orig).size() > 0)
  {
    auto newcont = std::make_unique<CONTAINER>();
    copyAuxStoreThinned (orig, *newcont, dec);
    return newcont;
  }

  return std::make_unique<CONTAINER> (orig);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param svc The thinning service.
 *
 * Returns a new copy of @c orig with elements removed according to the
 * thinning defined in @c svc.  Ownership of the new object is passed
 * back to the caller.
 *
 * The code here handles @c IAuxStore objects.
 * (For a @c DataVector object, use @c copyThinnedConst.)
 * Support for additional object types may be added by adding
 * overloads for @c copyThinned1.
 *
 * [To be removed as part of MT thinning work; use the variant below instead.]
 */
template <class CONTAINER>
CONTAINER* copyThinned (const CONTAINER& orig,
                        IThinningSvc* svc)
{
  return copyThinned1 (orig, &orig, svc);
}


/**
 * @brief Helper to copy an object while applying thinning.
 * @param orig The object to copy.
 * @param dec The thinning decision for this object.
 *
 * Returns a new copy of @c orig with elements removed according to the
 * thinning defined in @c svc.  Ownership of the new object is passed
 * back to the caller.
 *
 * The code here handles @c IAuxStore objects.
 * (For a @c DataVector object, use @c copyThinnedConst.)
 * Support for additional object types may be added by adding
 * overloads for @c copyThinned1.
 */
template <class CONTAINER>
std::unique_ptr<CONTAINER>
copyThinned (CONTAINER& orig,
             const SG::ThinningDecisionBase* dec)
{
  return copyThinned1 (orig, &orig, dec);
}


/**
 * @brief Helper to copy an object while applying thinning, const version.
 * @param orig The object to copy.
 * @param svc The thinning service.
 *
 * Returns a new copy of @c orig with elements removed according to the
 * thinning defined in @c svc.  Ownership of the new object is passed
 * back to the caller.
 *
 * The code here handles @c DataVector and @c IAuxStore objects.
 * Support for additional object types may be added by adding
 * overloads for @c copyThinned1.
 *
 * [To be removed as part of MT thinning work; use the variant below instead.]
 */
template <class CONTAINER>
const CONTAINER* copyThinnedConst (const CONTAINER& orig,
                                   IThinningSvc* svc)
{
  return copyThinned1 (orig, &orig, svc);
}


/**
 * @brief Helper to copy an object while applying thinning, const version.
 * @param orig The object to copy.
 * @param dec The thinning decision for this object.
 *
 * Returns a new copy of @c orig with elements removed according to the
 * thinning defined in @c svc.  Ownership of the new object is passed
 * back to the caller.
 *
 * The code here handles @c DataVector and @c IAuxStore objects.
 * Support for additional object types may be added by adding
 * overloads for @c copyThinned1.
 */
template <class CONTAINER>
std::unique_ptr<const CONTAINER>
copyThinnedConst (const CONTAINER& orig,
                  const SG::ThinningDecisionBase* dec)
{
  return copyThinned1 (orig, &orig, dec);
}


} // namespace SG
