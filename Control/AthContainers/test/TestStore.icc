/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// $Id$
/**
 * @file TestStore.icc
 * @author scott snyder <snyder@bnl.gov>
 * @date Dec, 2013
 * @brief Dummy event store, for regression tests.
 */

#include "SGTools/IProxyDictWithPool.h"
#include "SGTools/StringPool.h"
#include "SGTools/DataProxy.h"

#if __cplusplus < 201100
# include "CxxUtils/unordered_map.h"
namespace SG_STD_OR_SG = SG;
#else
# include <unordered_map>
namespace SG_STD_OR_SG = std;
#endif


struct TestStoreRemap
{
  TestStoreRemap (SG::sgkey_t the_key=0, size_t the_index = 0)
    : key (the_key), index (the_index) {}
  bool operator== (const TestStoreRemap& other) const
  { return other.key == key && other.index == index; }
  SG::sgkey_t key;
  size_t index;
};


struct TestStoreRemapHash
{
  size_t operator() (const TestStoreRemap& m) const
  { return m.key + m.index; }
};


class TestStore
  : public IProxyDictWithPool
{
public:
  unsigned long addRef()
  { std::cout << "addRef\n"; std::abort(); }
  unsigned long release()
  { std::cout << "release\n"; std::abort(); }
  StatusCode queryInterface(const InterfaceID &/*ti*/, void** /*pp*/)
  { std::cout << "queryInterface\n"; std::abort(); }
  const std::string& name() const
  { std::cout << "name\n"; std::abort(); }


  SG::DataProxy* deep_proxy(const void* const /*pTransient*/) const
  { std::cout << "deep_proxy\n"; std::abort(); }
  SG::DataProxy* proxy(const void* const pTransient) const
  { 
    tmap_t::const_iterator i = m_tmap.find (pTransient);
    if (i != m_tmap.end())
      return i->second;
    return 0;
  }
  SG::DataProxy* proxy(const CLID& /*id*/) const
  { std::cout << "proxy2\n"; std::abort(); }
  SG::DataProxy* proxy(const CLID& id, const std::string& key) const
  {
    sgkey_t sgkey = const_cast<TestStore*>(this)->stringToKey (key, id);
    kmap_t::const_iterator i = m_kmap.find (sgkey);
    if (i != m_kmap.end())
      return i->second;
    return 0;
  }
  virtual SG::DataProxy* proxy_exact (SG::sgkey_t sgkey) const 
  {
    kmap_t::const_iterator i = m_kmap.find (sgkey);
    if (i != m_kmap.end())
      return i->second;
    return 0;
  }
  std::vector<const SG::DataProxy*> proxies() const
  { std::cout << "proxies\n"; std::abort(); }

  sgkey_t stringToKey (const std::string& str, CLID clid)
  {
    return m_stringPool.stringToKey (str, clid);
  }
  const std::string* keyToString (sgkey_t /*key*/) const
  { std::cout << "keyToString1\n"; std::abort(); }
  const std::string* keyToString (sgkey_t key, CLID& clid) const
  {
    return m_stringPool.keyToString (key, clid);
  }
  void registerKey (sgkey_t /*key*/, const std::string& /*str*/, CLID /*clid*/)
  { std::cout << "registerKey\n"; std::abort(); }


  bool tryELRemap (sgkey_t sgkey_in, size_t index_in,
                   sgkey_t& sgkey_out, size_t& index_out)
  {
    remap_t::iterator i = m_remap.find (TestStoreRemap (sgkey_in, index_in));
    if (i == m_remap.end()) return false;
    sgkey_out = i->second.key;
    index_out = i->second.index;
    return true;
  }

  StatusCode addToStore (CLID /*id*/, SG::DataProxy* proxy)
  {
    proxy->setStore (this);
    m_kmap[proxy->transientAddress()->sgkey()] = proxy;
    return StatusCode::SUCCESS;
  }


  template <class T>
  void record (const T* p, const std::string& key)
  {
    DataObject* obj = SG::asStorable<T>(const_cast<T*>(p));
    CLID clid = ClassID_traits<T>::ID();
    sgkey_t sgkey = stringToKey (key, clid);
    if (m_kmap.find (sgkey) != m_kmap.end()) {
      SG::DataProxy* dp = m_kmap[sgkey];
      dp->setObject (obj);
      if (dp->transientAddress()->clID() == CLID_NULL)
        dp->transientAddress()->setID (clid, key);
      m_tmap[p] = dp;
      return;
    }

    SG::TransientAddress* tAddr = new SG::TransientAddress(clid, key);
    SG::DataProxy* dp = new SG::DataProxy(obj, tAddr);
    dp->setStore (this);
    m_tmap[p] = dp;

    m_kmap[sgkey] = dp;
    tAddr->setSGKey (sgkey);
  }


  void remap (sgkey_t sgkey_in, sgkey_t sgkey_out,
              size_t index_in = 0, size_t index_out = 0)
  {
    m_remap[TestStoreRemap(sgkey_in, index_in)] =
      TestStoreRemap(sgkey_out, index_out);
  }

  template <class T>
  void remap (const std::string& key_in, const std::string& key_out,
              size_t index_in = 0, size_t index_out = 0)
  {
    CLID clid = ClassID_traits<T>::ID();
    sgkey_t sgkey_in = stringToKey (key_in, clid);
    sgkey_t sgkey_out = stringToKey (key_out, clid);
    remap (sgkey_in, sgkey_out, index_in, index_out);
  }

  typedef SG_STD_OR_SG::unordered_map<const void*, SG::DataProxy*> tmap_t;
  tmap_t m_tmap;

  typedef SG_STD_OR_SG::unordered_map<sgkey_t, SG::DataProxy*> kmap_t;
  kmap_t m_kmap;

  typedef SG_STD_OR_SG::unordered_map<TestStoreRemap, TestStoreRemap, TestStoreRemapHash> remap_t;
  remap_t m_remap;

  SG::StringPool m_stringPool;
};


TestStore store;
IProxyDictWithPool* storePtr = &store;


IProxyDictWithPool** getTestDataSourcePointer (const std::string&)
{
  return &storePtr;
}

