/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// $Id$
/**
 * @file TestThinningSvc.icc
 * @author scott snyder <snyder@bnl.gov>
 * @date Jul, 2014
 * @brief Dummy thinning service, for regression tests.
 */


#include "SGTools/DataProxy.h"
#include "AthenaKernel/IThinningSvc.h"
#include <map>


class TestThinningSvc
  : public IThinningSvc
{
public:
  unsigned long addRef()
  { std::cout << "addRef\n"; std::abort(); }
  unsigned long release()
  { std::cout << "release\n"; std::abort(); }
  StatusCode queryInterface(const InterfaceID &/*ti*/, void** /*pp*/)
  { std::cout << "queryInterface\n"; std::abort(); }
  const std::string& name() const
  { std::cout << "name\n"; std::abort(); }
  SG::DataProxy* proxy(const void* const /*pTransient*/) const
  { std::cout << "proxy\n"; std::abort(); }
  SG::DataProxy* proxy(const CLID& /*id*/) const
  { std::cout << "proxy2\n"; std::abort(); }
  SG::DataProxy* proxy(const CLID& /*id*/, const std::string& /*key*/) const
  { std::cout << "proxy3\n"; std::abort(); }
  virtual SG::DataProxy* proxy_exact (SG::sgkey_t /*sgkey*/) const 
  { std::cout << "proxy_exact\n"; std::abort(); }
  StatusCode addToStore (CLID /*id*/, SG::DataProxy* /*proxy*/)
  { std::cout << "addToStore\n"; std::abort(); }
  std::vector<const SG::DataProxy*> proxies() const
  { std::cout << "proxies\n"; std::abort(); }
  StatusCode sysInitialize()
  { std::cout << "sysInitialize\n"; std::abort(); }
  StatusCode sysStart()
  { std::cout << "sysStart\n"; std::abort(); }
  StatusCode sysStop()
  { std::cout << "sysStop\n"; std::abort(); }
  StatusCode sysFinalize()
  { std::cout << "sysFinalize\n"; std::abort(); }
  StatusCode sysReinitialize()
  { std::cout << "sysReinitialize\n"; std::abort(); }
  StatusCode sysRestart()
  { std::cout << "sysRestart\n"; std::abort(); }
  StatusCode configure()
  { std::cout << "configure\n"; std::abort(); }
  StatusCode initialize()
  { std::cout << "initialize\n"; std::abort(); }
  StatusCode start()
  { std::cout << "start\n"; std::abort(); }
  StatusCode stop()
  { std::cout << "stop\n"; std::abort(); }
  StatusCode finalize()
  { std::cout << "finalize\n"; std::abort(); }
  StatusCode terminate()
  { std::cout << "terminate\n"; std::abort(); }
  StatusCode reinitialize()
  { std::cout << "reinitialize\n"; std::abort(); }
  StatusCode restart()
  { std::cout << "restart\n"; std::abort(); }
  Gaudi::StateMachine::State FSMState() const
  { std::cout << "FSMState\n"; std::abort(); }
  Gaudi::StateMachine::State targetFSMState() const
  { std::cout << "targetFSMState\n"; std::abort(); }
  void setServiceManager (ISvcManager*)
  { std::cout << "setServiceManager\n"; std::abort(); }
  StatusCode register_slimmer (Athena::ISlimmingHdlr */*handler*/)
  { std::cout << "register_slimmer\n"; std::abort(); }
  virtual Athena::IThinningHdlr* handler( SG::DataProxy* /*proxy*/ )
  { std::cout << "handler\n"; std::abort(); }
  virtual StatusCode
  filter_impl( Athena::IThinningHdlr* /*handler*/,
               SG::DataProxy* /*proxy*/,
               const Filter_t& /*filter*/,
               const IThinningSvc::Operator::Type /*op*/ = Operator::And )
  { std::cout << "filter_impl\n"; std::abort(); }
  StatusCode commit()
  { std::cout << "commit\n"; std::abort(); }
  StatusCode rollback()
  { std::cout << "rollback\n"; std::abort(); }

  bool thinningOccurred() const
  {
    return m_map.size() > 0;
  }

  bool is_thinned_impl(const SG::DataProxy* p) const
  {
    proxymap_t::const_iterator i = m_map.find (p);
    if (i != m_map.end())
      return true;
    return false;
  }

  SG::DataProxy* deep_proxy(const void* const pTransient) const
  {
    objmap_t::const_iterator i = m_objmap.find (pTransient);
    if (i != m_objmap.end())
      return i->second;
    return 0;
  }

  std::size_t index_impl( const SG::DataProxy* objProxy, 
                          std::size_t idx ) const 
  {
    proxymap_t::const_iterator i = m_map.find (objProxy);
    if (i != m_map.end()) {
      map_t::const_iterator ii = i->second.find (idx);
      if (ii != i->second.end())
        return ii->second;
    }
    return idx;
  }

  void remap (const void* obj, size_t from, size_t to)
  {
    SG::DataProxy* proxy = m_objmap[obj];
    if (!proxy) {
      proxy = new SG::DataProxy();
      m_objmap[obj] = proxy;
    }

    m_map[proxy][from] = to;
  }


  typedef std::map<const void*, SG::DataProxy*> objmap_t;
  objmap_t m_objmap;

  typedef std::map<size_t, size_t> map_t;

  typedef std::map<const SG::DataProxy*, map_t> proxymap_t;
  proxymap_t m_map;
};
