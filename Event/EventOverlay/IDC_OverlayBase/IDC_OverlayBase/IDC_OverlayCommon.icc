/*
  Copyright (C) 2002-2019 CERN for the benefit of the ATLAS collaboration
*/

// Generic overlaying code for Identifiable Containers.
//
// Andrei Gaponenko <agaponenko@lbl.gov>, 2006-2009

#include "Identifier/Identifier.h"
#include "Identifier/IdentifierHash.h"

#include "StoreGate/ReadHandle.h"
#include "StoreGate/WriteHandle.h"
 

#include "AthenaBaseComps/AthMsgStreamMacros.h"

#include "AthContainers/DataVector.h"

#include <sstream>

namespace Overlay {

  //================================================================
  template<class IDC_Container, class OvlAlg>
  void overlayContainerNew(const IDC_Container *dataContainer,
			const IDC_Container *mcContainer,
                        IDC_Container *outputContainer,       
			OvlAlg *parent)
  {
   typedef typename IDC_Container::base_value_type Collection;
   std::cout<<"start overlayContainer"<<std::endl;
   if(parent->msgLvl(MSG::DEBUG)) { parent->msg(MSG::DEBUG)<<"overlayContainerNew<>() begin"<<endmsg; }

   //There are some use cases where this is empty
   if(dataContainer != nullptr){
   /** Add data from the data container to the output one */
      typename IDC_Container::const_iterator p_data = dataContainer->begin();
      typename IDC_Container::const_iterator p_data_end = dataContainer->end();

      for(; p_data != p_data_end; ++p_data) {
         IdentifierHash hashId = p_data.hashId();
         auto coll_data = std::make_unique<Collection>(hashId); 
         copyCollection(*p_data,coll_data.get());
   
         if ( outputContainer->addCollection(coll_data.release(), p_data.hashId()).isFailure() ) {
            parent->msg(MSG::WARNING) <<"add data Collection failed for output "<< p_data.hashId   ()<<endmsg; //" collectionNo "<<collectionNo<<endmsg; 
         } 
      }
   }

   /** Add data from the ovl container to the output one */
   typename IDC_Container::const_iterator p_ovl = mcContainer->begin(); 
   typename IDC_Container::const_iterator p_ovl_end = mcContainer->end();

   for(; p_ovl != p_ovl_end; ++p_ovl) {
 
      IdentifierHash coll_id = p_ovl.hashId();//(*p_ovl)->identify();
      auto coll_ovl = std::make_unique<Collection>(coll_id);	
      copyCollection(*p_ovl,coll_ovl.get());

      /** The newly created stuff will go to the output EventStore SG */
      auto coll_out = std::make_unique<Collection>(coll_id);
      coll_out->setIdentifier((*p_ovl)->identify());

      /** Look for the same ID in the main StoreGate EventStore */ 
      typename IDC_Container::const_iterator q = outputContainer->indexFind( coll_id );
      if( q != outputContainer->end() ) {
      /**Need to merge the collections
         Retrieve q */
         std::unique_ptr <Collection> coll_data ((Collection *) *q);
         mergeCollectionsNew(coll_data.get(),coll_ovl.get(),coll_out.get(),parent);

         outputContainer->removeCollection(p_ovl.hashId());
         if (outputContainer->addCollection(coll_out.release(), p_ovl.hashId()).isFailure() ) {
      	    parent->msg(MSG::WARNING) << "overlay addCollection failed " << endmsg; 
         }
      }
    else {
       /** Copy the complete collection from ovl to output, 
           hopefully preserving the "most derived" type of its raw data */ 
       if ( outputContainer->addCollection(coll_ovl.release(), coll_id).isFailure() ) {
       	  parent->msg(MSG::WARNING) << "add mc Collection failed " << endmsg; 
      }
    }   
   }
  }


  //================================================================
  template<class IDC_Container, class OvlAlg>
  void overlayContainer(const IDC_Container *dataContainer,
			const IDC_Container *mcContainer,
			IDC_Container *outputContainer,	      
			OvlAlg *parent)
  {
    typedef typename IDC_Container::base_value_type Collection;
    typedef typename Collection::base_value_type Datum;		
 
    if(parent->msgLvl(MSG::DEBUG)) { parent->msg(MSG::DEBUG)<<"overlayContainer<>() begin"<<endmsg; }
    
    // The  MC signal container should typically be smaller than
    // dataContainer, because the latter contains all the noise,
    // min bias and pile up.   Thus we firstly copy data collection to the 
    // output and then merge with MC inputs.

    /** Add data from the data container to the output one */
    typename IDC_Container::const_iterator p_data = dataContainer->begin();
    typename IDC_Container::const_iterator p_data_end = dataContainer->end();
 
    for(; p_data != p_data_end; ++p_data) {
       IdentifierHash hashId = p_data.hashId();
       Identifier ident = p_data->identify();	
       auto coll_data = std::make_unique<Collection>(ident, hashId);	
      
       typename Collection::const_iterator firstData = p_data->begin();
       typename Collection::const_iterator lastData = p_data->end();    
       for (; firstData != lastData; ++firstData) {		       
          Datum* newData = new Datum (*(dynamic_cast<const Datum*>(*firstData)));
          coll_data->push_back(newData);
       }	
   
       if ( outputContainer->addCollection(coll_data.release(), p_data.hashId()).isFailure() ) {
          parent->msg(MSG::WARNING) <<"add data Collection failed for output "<< p_data.hashId()<<endmsg; 
      }
    }     

    /** Add data from the ovl container to the output one */
    typename IDC_Container::const_iterator p_ovl = mcContainer->begin(); 
    typename IDC_Container::const_iterator p_ovl_end = mcContainer->end();

    for(; p_ovl != p_ovl_end; ++p_ovl) {
       IdentifierHash coll_id = p_ovl.hashId();//(*p_ovl)->identify();
       Identifier elemId = p_ovl->identify();
       auto coll_ovl = std::make_unique<Collection>(elemId, coll_id);	
     
       typename Collection::const_iterator firstData = p_ovl->begin();
       typename Collection::const_iterator lastData = p_ovl->end();    
       for (; firstData != lastData; ++firstData) {		       
          Datum* newData = new Datum (*(dynamic_cast<const Datum*>(*firstData)));
          coll_ovl->push_back(newData);
    }	
   	
       /** The newly created stuff will go to the output EventStore SG */
       auto coll_out = std::make_unique<Collection>(elemId, coll_id);	    
     
       /** Look for the same ID in the main StoreGate EventStore */ 
       typename IDC_Container::const_iterator q = outputContainer->indexFind(coll_id);
       if( q != outputContainer->end() ) {
       /** Need to merge the collections
           Retrieve q */

          std::unique_ptr <Collection> coll_data ((Collection *) *q);
          parent->mergeCollections(coll_data.get(),coll_ovl.get(),coll_out.get());

          outputContainer->removeCollection(p_ovl.hashId());
          if (outputContainer->addCollection(coll_out.release(), p_ovl.hashId()).isFailure() ) {
	     parent->msg(MSG::WARNING) << "overlay addCollection failed " << endmsg; 
          }
       }
       else {
       /** Copy the complete collection from ovl to output, 
           hopefully preserving the "most derived" type of its raw data */ 
           if ( outputContainer->addCollection(coll_ovl.release(), coll_id).isFailure() ) {
              parent->msg(MSG::WARNING) << "add mc Collection failed " << endmsg; 
           }  
       }   
    }  
 }

} // namespace Overlay

//================================================================
