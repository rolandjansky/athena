/**
 * Copyright (C) 2002-2022 CERN for the benefit of the ATLAS collaboration.
 *
 * @file HGTD_TruthTools/src/ClusterTruthTool.cxx
 *
 * @author Alexander Leopold <alexander.leopold@cern.ch>
 * @author Noemi Calace <noemi.calace@cern.ch>
 *
 * @date August, 2021
 *
 * @brief
 */

#include "ClusterTruthTool.h"

#include "GeneratorObjects/McEventCollection.h"
#include "HGTD_PrepRawData/HGTD_Cluster.h"
#include "InDetSimData/InDetSimDataCollection.h"
#include "xAODTruth/TruthParticle.h"

#include "TLorentzVector.h"

HGTD::ClusterTruthTool::ClusterTruthTool(const std::string& t,
                                         const std::string& n,
                                         const IInterface* p)
    : base_class(t, n, p) {}

HGTD::ClusterTruthInfo HGTD::ClusterTruthTool::classifyCluster(
    const HGTD_Cluster* cluster, const xAOD::TruthParticle* tp,
    const InDetSimDataCollection* sim_data,
    const HepMC::GenEvent* hard_scatter_evnt) const {

  if (not sim_data) {
    return {HGTD::ClusterTruthOrigin::UNIDENTIFIED, false, false};
  }

  const std::vector<Identifier>& rdo_id_list = cluster->rdoList();
  // keep record of the cluster origins and if they are shadowed or not
  std::vector<std::pair<HGTD::ClusterTruthOrigin, bool>> shadowed_origins;

  for (const auto& rdo_id : rdo_id_list) {

    auto pos = sim_data->find(rdo_id);
    // the InDetSimData contains a std::pair<HepMcParticleLink, float>, where
    // the second entry in the pair holds the time of the SiChargedDiode
    if (pos == sim_data->end()) {
      ATH_MSG_WARNING("[HGTD::ClusterTruthTool::classifyCluster] ID not found in SDO "
                      "map, going to next ID");
      // FIXME I should probably continue here already? otherwise I get an
      // "empty" entry in shadowed_origins
      continue;
    }
    // collect deposits, sorted with first deposit at start of map bu default
    std::map<float, HGTD::ClusterTruthOrigin> sorted_deposits;

    //////////////////////////////
    // the following is taken from 20.20 as is
    for (const auto& deposit : pos->second.getdeposits()) {
      const HepMcParticleLink& particle_link = deposit.first;
      int barcode = particle_link.barcode();

      // barcodes of 0 or above 200k are secondaries generated by GEANT4
      // 0 is also used for detector noise, delta rays and random energy
      // deposits
      if (barcode == 0 || barcode > 200000) {
        sorted_deposits.emplace(deposit.second, HGTD::ClusterTruthOrigin::SECONDARY);
        // FIXME: shouldn't I "continue" here?
      }
      // check for identity with original particle
      const HepMC::GenParticle* gen_part = particle_link.cptr();
      if (gen_part) {
        TLorentzVector l4(gen_part->momentum().px(), gen_part->momentum().py(),
                          gen_part->momentum().pz(), gen_part->momentum().e());
        // if the barcode is identical and spacial matching passes, then this
        // deposit came from the tested truth particle
        if (barcode == tp->barcode() && tp->p4().DeltaR(l4) < 0.05) {
          sorted_deposits.emplace(deposit.second,
                                  HGTD::ClusterTruthOrigin::TRUTH_PARTICLE);
          // if given, the parent event can be checked
        } else if (hard_scatter_evnt and
                   gen_part->parent_event() == hard_scatter_evnt) {
          sorted_deposits.emplace(deposit.second,
                                  HGTD::ClusterTruthOrigin::HARD_SCATTER);
          // otherwise, a particle that was generated but doesn't come from the
          // hard scatter is considered to be originating from a pileup
          // interaction
        } else {
          sorted_deposits.emplace(deposit.second, HGTD::ClusterTruthOrigin::PILEUP);
        }
      } else {
        // if there is no gen particle, we can guess based on the event index
        if (particle_link.eventIndex() == 0) {
          sorted_deposits.emplace(deposit.second,
                                  HGTD::ClusterTruthOrigin::HARD_SCATTER);
        } else {
          // If the gen was not kept, we assume it is cut away from truth record
          // and is pileup
          sorted_deposits.emplace(deposit.second, HGTD::ClusterTruthOrigin::PILEUP);
        }
      }
    } // END lOOP over the deposits

    // check for shadowing, which means that a deposit was left by the truth
    // particle, but it was not the first deposit and is thus not used for the
    // time measurement -> I will have an incorrect time
    bool is_shadowed = false;
    HGTD::ClusterTruthOrigin current_origin = HGTD::ClusterTruthOrigin::UNIDENTIFIED;

    std::map<float, HGTD::ClusterTruthOrigin>::iterator elem =
        sorted_deposits.begin();

    for (; elem != sorted_deposits.end(); ++elem) {
      if (elem == sorted_deposits.begin()) {
        current_origin = elem->second;
      } else {
        // if one of the later deposits originates from the truth particle, then
        // the hit I want to find was shadowed by something else, and I will
        // reconstruct an incorrect time
        if (current_origin != HGTD::ClusterTruthOrigin::TRUTH_PARTICLE &&
            elem->second == HGTD::ClusterTruthOrigin::TRUTH_PARTICLE) {
          is_shadowed = true;
        }
      }
    } // END LOOP over the time sorted deposits
    shadowed_origins.emplace_back(current_origin, is_shadowed);
  } // END LOOP over RDO identifiers

  HGTD::ClusterTruthInfo result;

  if (shadowed_origins.size() == 0) {
    ATH_MSG_WARNING("did not manage to understand any RDOs...");
    result.origin = HGTD::ClusterTruthOrigin::UNIDENTIFIED;
    result.is_shadowed = false;
    // A cluster is considered to be merged if more than one particle deposited
    // energy in a given pad.
    result.is_merged = false;
  } else {
    result.is_merged = false;
    result.origin = shadowed_origins.at(0).first;
    result.is_shadowed = shadowed_origins.at(0).second;
    for (size_t i = 1; i < shadowed_origins.size(); ++i) {
      if (shadowed_origins.at(i).first != result.origin) {
        result.is_merged = true;
      } else {
        result.is_shadowed |= shadowed_origins.at(i).second;
      }
    }
  }
  return result;
}
