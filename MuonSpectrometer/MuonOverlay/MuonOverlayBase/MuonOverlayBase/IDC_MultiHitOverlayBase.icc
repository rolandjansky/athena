/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/


// Ketevi A. Assamagan, 2009
 
#include "Identifier/Identifier.h"
#include "Identifier/IdentifierHash.h"

#include "AthenaBaseComps/AthMsgStreamMacros.h"

#include "AthContainers/DataVector.h"

#include "StoreGate/StoreGateSvc.h"
#include <memory>

#include <sstream>

#include <set>

//================================================================
namespace Overlay {
  
  template<class Datum>  
  void mergeMultiHits(std::vector<Datum*>& dataHits, 
                      std::vector<Datum*>& mcHits,                        
                      std::vector<Datum*>& outHits, IDC_MultiHitOverlayBase* parent) {
  
     parent->msg(MSG::DEBUG) << "Overlay::mergeMultiHits() : " << typeid(Datum).name() << endmsg;

     outHits.clear();

     /** here we take all the hits. SubSystems can to more sophisticated selections
         in their template specializations */ 
     for (unsigned int i=0; i<dataHits.size(); ++i) outHits.push_back( dataHits.at(i) );
     for (unsigned int j=0; j<mcHits.size(); ++j) outHits.push_back( mcHits.at(j) );
  }
}

//================================================================
template<class Collection>
void IDC_MultiHitOverlayBase::mergeCollections(Collection *mc_coll, 
				       Collection *data_coll, 
				       Collection *out_coll)
{
  DataVector<typename Collection::base_value_type> mc;
  mc_coll->swap(mc);

  DataVector<typename Collection::base_value_type> data;
  data_coll->swap(data);
  
  //################################################################
  // Merge by copying ptrs from data and mc to mc_coll

  typename Collection::size_type idata = 0;
  typename Collection::size_type imc = 0;
  typename Collection::size_type j;
  typename Collection::size_type k;
 
  /** this is the set of the all the hits treated
      when all is done, it should be the union of data and MC hits */
  std::set<Identifier> ids;

  /** merge hits on the same channel */
  while ( imc < mc.size() ) {
    /** collect all the mc hits of a given Identifer id */
    typename Collection::base_value_type *p_rdo(0);
    std::vector<typename Collection::base_value_type *> vect1;
    if ( !mc[imc] ) { imc++; continue; }
    Identifier id = mc[imc]->identify();
    if(!(ids.insert(id)).second) { imc++; continue; } // this Id already treated -> move on 
    mc.swapElement(imc++, 0, p_rdo);
    vect1.push_back(p_rdo);
    for ( j=imc; j<mc.size(); j++ ) {
       if ( !mc[j] ) continue;
       if ( mc[j]->identify() == id ) {
          mc.swapElement(j, 0, p_rdo);
          vect1.push_back(p_rdo);
       }
    }

    /** collect all the data hits of the same Identifier id */
    typename Collection::base_value_type *p_data(0);
    std::vector<typename Collection::base_value_type *> vect2; 
    for ( k=0; k<data.size(); k++ ) {
       if ( !data[k] ) continue;
       if ( data[k]->identify() == id ) {
          data.swapElement(k, 0, p_data);
          vect2.push_back(p_data);
       }
    }

    /** now we have vect1 and vect2 for same Id channels, 
        call the multi hit overlay and save the merged hits */
    if ( vect2.size() > 0 ) { // no need to merge hits if data in empty 
       std::vector<typename Collection::base_value_type *> vect;
       Overlay::mergeMultiHits(vect1,vect2,vect,this);
       for (unsigned int n=0; n<vect.size(); ++n) out_coll->push_back( vect.at(n) );
    } else {                    // copy directly mc if data is empty
       for (unsigned int n=0; n<vect1.size(); ++n) out_coll->push_back( vect1.at(n) );
    }
  }
   
  /** now there must be some hits in the data that are not treated yet -
      deal with those at this time. These should be the hit Ids that
      are in the data but not found in the MC */
  while( idata < data.size() ) {
   if ( !data[idata] ) { idata++; continue; }
   Identifier id = data[idata]->identify();
   if(!(ids.insert(id)).second) { idata++; continue; } // this Id was found and treated already above -> continue
   typename Collection::base_value_type *p_data(0);
   data.swapElement(idata++, 0, p_data);
   out_coll->push_back( p_data );
  }
 
}
