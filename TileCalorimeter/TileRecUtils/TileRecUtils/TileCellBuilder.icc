/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

#include "TileEvent/TileCell.h"
#include "DataModel/DataPool.h"

// Atlas includes

// Calo includes
#include "CaloIdentifier/CaloCell_ID.h"
#include "CaloDetDescr/CaloDetDescrElement.h"
#include "CaloDetDescr/MbtsDetDescrManager.h"
#include "Identifier/IdentifierHash.h"

// Tile includes
#include "CaloIdentifier/TileID.h"
#include "CaloIdentifier/TileTBID.h"
#include "TileIdentifier/TileHWID.h"
#include "TileDetDescr/TileDetDescrManager.h"
#include "TileCalibBlobObjs/TileCalibUtils.h"
#include "TileConditions/TileCondToolEmscale.h"
#include "TileConditions/TileCondToolTiming.h"
#include "TileEvent/TileRawChannel.h"
#include "TileRecUtils/TileRawChannelBuilder.h"


template<class ITERATOR, class COLLECTION>
void TileCellBuilder::build(const ITERATOR & begin, const ITERATOR & end, COLLECTION * coll) {

  // disable checks for TileID and remember previous state
  bool do_checks = m_tileID->do_checks();
  m_tileID->set_do_checks(false);
  bool do_checks_tb = m_tileID->do_checks();
  m_tileTBID->set_do_checks(false);

  // Now retrieve the TileDQStatus
  theDQstatus = m_beamInfo->getDQstatus();

  /* zero all counters and sums */
  int nTwo = 0;
  int nCell = 0;
  int nFake = 0;
  int nMBTS = 0;
  int nE4pr = 0;
  int nChan = 0;
  float eCh = 0.0;
  float eCellTot = 0.0;
  float eMBTSTot = 0.0;
  float eE4prTot = 0.0;
  bool EBdrawerPresent[128];
  memset(EBdrawerPresent, 0, sizeof(EBdrawerPresent));

  static DataPool<TileCell> tileCellsP(5217);
  //**
  //* Iterate over raw channels, creating new TileCells (or incrementing
  //* existing ones). Add each new TileCell to the output collection
  //**

  for (ITERATOR rawItr = begin; rawItr != end; ++rawItr) {

    const TileRawChannel* pChannel = (*rawItr);
    HWIdentifier adc_id = pChannel->adc_HWID();
    int ros = m_tileHWID->ros(adc_id);
    int drawer = m_tileHWID->drawer(adc_id);
    int channel = m_tileHWID->channel(adc_id);
    int gain = m_tileHWID->adc(adc_id);
    if (gain == m_skipGain) {
      ATH_MSG_VERBOSE (" skipping adc_id=" << m_tileHWID->to_string(adc_id));
      continue; // select only one of two gains in calib runs
    }
    int drawerIdx = TileCalibUtils::getDrawerIdx(ros, drawer);
    if (channel == 0 && ros > 2) EBdrawerPresent[(ros - 3) * 64 + drawer] = true; // EB drawer appeared in the data

    float time = pChannel->uncorrTime(); // take uncorrected time (if available)
    float amp = pChannel->amplitude();

    TileRawChannelUnit::UNIT oldUnit = m_RChUnit;
    if (m_correctAmplitude && time > m_timeMinThresh && time < m_timeMaxThresh) { // parabolic correction
      if (m_RChUnit > TileRawChannelUnit::OnlineADCcounts) { // convert from online units to ADC counts
        oldUnit = TileRawChannelUnit::ADCcounts;
        amp = m_tileToolEmscale->undoOnlCalib(drawerIdx, channel, gain, amp, m_RChUnit);
        if (amp > m_ampMinThresh) // amp cut in ADC counts
          amp *= TileRawChannelBuilder::correctAmp(time);
      } else if (amp > m_ampMinThresh
                && (m_RChUnit == TileRawChannelUnit::ADCcounts
                    || m_RChUnit == TileRawChannelUnit::OnlineADCcounts)) {

        amp *= TileRawChannelBuilder::correctAmp(time);
      } else {
        ATH_MSG_ERROR( "Units in raw channel container is " << m_RChUnit );
        ATH_MSG_ERROR( "But amplitude correction works only with ADC counts " );
        ATH_MSG_ERROR( "Please, disable CIS calibration in optimal filter " );
      }
    }

    float qual = pChannel->quality();

    // check that time was really reconstructed
    bool good_time = (fabs(time) < m_maxTimeCorr);
    bool non_zero_time = (m_RChType == TileFragHash::OptFilterDspCompressed)
                          ? ((qual > 2.99 && qual < 4.01))
                          : ((qual > 0.0 || m_RChType == TileFragHash::OptFilterDsp));

    // new feature in rel 17.2.7 - pedestal keeps information about overflow and underflow
    // if there is an underflow, 10000 is added to pedestal value
    // if there is an overflow,  20000 is added to pedestal value
    // if there is an underflow in all samples, 80000 is added to pedestal value
    // if there is an overflow in all samples,  90000 is added to pedestal value
    // if there is bad pattern nunber N 100000+N*10000 is added to pedestal value
    bool overflow = false;
    bool underflow = false;
    bool overfit = false;
    float ped = pChannel->pedestal();
    if (ped > 55000.) { // one of bad patterns
      qual = 9999; // mask all bad patterns
    } else if (ped > 39500.) { // 40000 for constant value or 50000 for all zeros in disconnexted channel
      // nothing to do
    } else if (ped > 5000.) { // 10000 for underflow or 20000 for overflow or 10000+20000
      underflow = ((ped < 15000.) || (ped > 29500.));
      overflow = (ped > 15000.);
      // special flag indicating that fit method was applied for overflow channels
      overfit = ( (ped >= 22500 && ped < 29500) || (ped >= 32500 && ped < 39500) );

      if (overflow
          && gain == TileID::LOWGAIN
          && amp > 0
          && time > m_timeMinThresh
          && time < m_timeMaxThresh) {

        qual = fabs(qual);
        if (qual > m_qualityCut && qual < 9999.) {
          qual = m_qualityCut; // to avoid masking of overflow in low gain
        }
      }
    }

    // apply time correction if needed
    if (m_correctTime && good_time && non_zero_time)
      time -= m_tileToolTiming->getSignalPhase(drawerIdx, channel, gain);
    else
      time = pChannel->time();

    ++nChan;
    eCh += amp;

    int index, pmt;
    Identifier cell_id = (TileCablingService::getInstance())->h2s_cell_id_index (ros, drawer, channel, index, pmt);

    if (index == -3) { // E4' cells

      if (m_E4prCells) { // do something with them only if contaier existst
        ++nE4pr;

        // convert ADC counts to MeV. like for normal cells
        float ener = m_tileToolEmscale->channelCalib(drawerIdx, channel, gain, amp , oldUnit
                                                     , TileRawChannelUnit::MegaElectronVolts);

        eE4prTot += ener;
        unsigned char iqual = iquality(qual);
        // for E4' cell qbit use only non_zero_time flag and check that energy is above standatd energy threshold in MeV
        unsigned char qbit = qbits(ros, drawer, true, non_zero_time, (fabs(ener) > m_eneForTimeCut)
                                   , overflow, underflow, overfit);
        CaloGain::CaloGain cgain = (gain == TileID::HIGHGAIN)
                                   ? CaloGain::TILEONEHIGH
                                   : CaloGain::TILEONELOW;

        TileCell* pCell = tileCellsP.nextElementPtr();
        // no CaloDDE
        // Cell ID is set explicitly
        pCell->set(NULL, cell_id);
        pCell->setEnergy_nonvirt(ener, 0, cgain, 3);
        pCell->setTime_nonvirt(time);
        pCell->setQual1(iqual);
        pCell->setQual2(0);
        pCell->setQbit1(qbit);
        pCell->setQbit2(0);

        if (msgLvl(MSG::VERBOSE)) {
          msg(MSG::VERBOSE) << " E4'  cell_id=" << m_tileTBID->to_string(cell_id)
                            << " adc_id=" << m_tileHWID->to_string(adc_id)
                            << " ene= " << ener
                            << " amp= " << amp
                            << " time= " << time
                            << " qual= " << pChannel->quality()
                            << " iqual= " << (int) iqual
                            << " qbit = 0x" << MSG::hex << (int) qbit << MSG::dec;

          if (ped > 5000)
            msg(MSG::VERBOSE) << " err = " << TileRawChannelBuilder::BadPatternName(ped) << endmsg;
          else
            msg(MSG::VERBOSE) << endmsg;
        }

        if (m_maskBadChannels && maskBadChannel(pCell, adc_id))
          ATH_MSG_VERBOSE ( "cell with id=" << m_tileTBID->to_string(cell_id)
                             << " bad channel masked, new energy=" << pCell->energy() );

        m_E4prCells->push_back(pCell); // store cell in container

      }

    } else if (index == -2) { // MBTS cells

      if (m_MBTSCells) { // do something with them only if contaier existst
        ++nMBTS;

        // convert ADC counts to pCb and not to MeV
        float ener = m_tileToolEmscale->channelCalib(drawerIdx, channel, gain, amp , oldUnit
                                                     , TileRawChannelUnit::PicoCoulombs);

        eMBTSTot += ener;
        unsigned char iqual = iquality(qual);
        // for MBTS qbit use AND of good_time and non_zero_time and check that energy is above MBTS energy threshold in pC
        unsigned char qbit = qbits(ros, drawer, false, (good_time && non_zero_time)
           , (fabs(ener) > m_eneForTimeCutMBTS), overflow, underflow, overfit);
        CaloGain::CaloGain cgain = (gain == TileID::HIGHGAIN)
                                   ? CaloGain::TILEONEHIGH
                                   : CaloGain::TILEONELOW;

        TileCell* pCell = tileCellsP.nextElementPtr();
        // MBTS CaloDDE
        // Cell ID is set explicitly
        pCell->set((m_mbtsMgr) ? m_mbtsMgr->get_element(cell_id) : NULL, cell_id);
        pCell->setEnergy_nonvirt(ener, 0, cgain, 3);
        pCell->setTime_nonvirt(time);
        pCell->setQual1(iqual);
        pCell->setQual2(0);
        pCell->setQbit1(qbit);
        pCell->setQbit2(0);

        if (msgLvl(MSG::VERBOSE)) {
          msg(MSG::VERBOSE) << " MBTS cell_id=" << m_tileTBID->to_string(cell_id)
                            << " adc_id=" << m_tileHWID->to_string(adc_id)
                            << " ene= " << ener
                            << " amp= " << amp
                            << " time= " << time
                            << " qual= " << pChannel->quality()
                            << " iqual= " << (int) iqual
                            << " qbit = 0x" << MSG::hex << (int) qbit << MSG::dec;

          if (ped > 5000)
            msg(MSG::VERBOSE) << " err = " << TileRawChannelBuilder::BadPatternName(ped) << endmsg;
          else
            msg(MSG::VERBOSE) << endmsg;
        }

        if (m_maskBadChannels && maskBadChannel(pCell, adc_id))
          ATH_MSG_VERBOSE ( "cell with id=" << m_tileTBID->to_string(cell_id)
                             << " bad channel masked, new energy=" << pCell->energy() );

        m_MBTSCells->push_back(pCell); // store cell in container

      }
    } else if (index != -1) { // connected channel

      float ener = m_tileToolEmscale->channelCalib(drawerIdx, channel, gain, amp
           , oldUnit, TileRawChannelUnit::MegaElectronVolts);

      eCellTot += ener;
      
      unsigned char iqual = iquality(qual);
      // for normal cell qbit use only non_zero_time flag and check that energy is above standatd energy threshold in MeV
      unsigned char qbit = qbits(ros, drawer, true, non_zero_time, (fabs(ener) > m_eneForTimeCut)
          , overflow, underflow, overfit);


      if ( (TileCablingService::getInstance())->getCablingType() == TileCablingService::RUN2Cabling
      	   && channel == E1_CHANNEL
	   && ros > 2) { // Raw channel -> E1 cell.

       int drawer2 = (TileCablingService::getInstance())->E1_merged_with_run2(ros,drawer);
       if (drawer2 != 0) { // Raw channel splitted into two E1 cells for Run 2.
         int side = (ros == 3) ? 1 : -1;
         Identifier cell_id2 = m_tileID->cell_id(TileID::GAPDET, side, drawer2, E1_TOWER, TileID::SAMP_E);
         int index2 = m_tileID->cell_hash(cell_id2);
         TileCell* pCell2 = tileCellsP.nextElementPtr();
         ++nCell;
         m_allCells[index2] = pCell2;
         const CaloDetDescrElement* dde2 = m_tileMgr->get_cell_element(index2);
         pCell2->set(dde2, cell_id2);
         pCell2->setEnergy_nonvirt(0, 0, CaloGain::INVALIDGAIN, CaloGain::INVALIDGAIN);
         int pmt2(0);
         ener /= 2.0F;
         correctCell(pCell2, 1, pmt2, gain, ener, time, iqual, qbit, 1);
   
         ATH_MSG_DEBUG("E1 cell Id => " << m_tileID->to_string(cell_id)
                      << " splitted into " << m_tileID->to_string(cell_id2));


       }

     }




      TileCell* pCell = m_allCells[index];
      if (pCell) {
        ++nTwo;
        correctCell(pCell, 2, pmt, gain, ener, time, iqual, qbit, 0); // correct & merge 2 PMTs in one cell
      } else {
        ++nCell;
        m_allCells[index] = pCell = tileCellsP.nextElementPtr();
        const CaloDetDescrElement* dde = m_tileMgr->get_cell_element(index);
        pCell->set(dde, cell_id);
        pCell->setEnergy_nonvirt(0, 0, CaloGain::INVALIDGAIN, CaloGain::INVALIDGAIN);
        int ch_type = (dde->onl2() == TileHWID::NOT_VALID_HASH) ? 1 : 0;
        correctCell(pCell, 1, pmt, gain, ener, time, iqual, qbit, ch_type); // correct & save e,t,q in new cell
      }

      if (msgLvl(MSG::VERBOSE)) {
        float calib1 = (amp != 0) ? ener / amp : 0.0;
        msg(MSG::VERBOSE) << " cell_id=" << m_tileID->to_string(cell_id, -2)
                          << " adc_id=" << m_tileHWID->to_string(adc_id)
                          << " calib=" << calib1
                          << " nCell=" << nCell
                          << " energy=" << ener << " (" << pCell->energy() << ", " << pCell->eneDiff() << ")" << endmsg;

        msg(MSG::VERBOSE) << " amp= " << amp
                          << " time= " << time
                          << " qual= " << pChannel->quality()
                          << " iqual= " << (int) iqual
                          << " qbit = 0x" << MSG::hex << (int) qbit << MSG::dec;

        if (ped > 5000)
          msg(MSG::VERBOSE) << " err = " << TileRawChannelBuilder::BadPatternName(ped) << endmsg;
        else
          msg(MSG::VERBOSE) << endmsg;
      }
      
    } else {

      if (msgLvl(MSG::VERBOSE)) {

        unsigned char iqual = iquality(qual);
        unsigned char qbit = qbits(0, drawer, false, non_zero_time, false, overflow, underflow, overfit); //fake ros number here

        msg(MSG::VERBOSE) << " channel with adc_id=" << m_tileHWID->to_string(adc_id)
                          << " is not connected" << endmsg;

        msg(MSG::VERBOSE) << " amp= " << amp
                          << " time= " << time
                          << " qual= " << pChannel->quality()
                          << " iqual= " << (int) iqual
                          << " qbit = 0x" << MSG::hex << (int) qbit << MSG::dec;

        if (ped > 5000)
          msg(MSG::VERBOSE) << " err = " << TileRawChannelBuilder::BadPatternName(ped) << endmsg;
        else
          msg(MSG::VERBOSE) << endmsg;
      }
    }
    if (msgLvl(MSG::VERBOSE)) {
      if ((m_correctTime && good_time && non_zero_time) || pChannel->sizeTime() > 1) {
        msg(MSG::VERBOSE) << " OF_time = " << pChannel->uncorrTime()
                          << " corr_time = " << time << endmsg;
      }
    }
  }

  //**
  // Now store all TileCells  
  //**
  for (unsigned int index = 0; index < m_allCells.size(); ++index) {

    TileCell * pCell = m_allCells[index];

    if (pCell) {      // cell exists

      if (m_maskBadChannels)
        if (maskBadChannels(pCell))
          ATH_MSG_VERBOSE ( "cell with id=" << m_tileID->to_string(pCell->ID(), -2)
                           << " bad channels masked, new energy=" << pCell->energy() );

      if (m_thresholdNotSet
          || (pCell->energy() > m_eThreshold
              && fabs(pCell->timeDiff()) < m_maxTimeDiff
              && pCell->time1() < m_maxTime && pCell->time1() > m_minTime
              && pCell->time2() < m_maxTime && pCell->time2() > m_minTime
              && pCell->qual1() > m_minChi2 && pCell->qual1() < m_maxChi2
              && pCell->qual2() > m_minChi2 && pCell->qual2() < m_maxChi2)) {

        coll->push_back(pCell); // store cell in container

      } else {

        //delete pCell; it's dangerous to delete cell, if it's in DataPool 

      }

      m_allCells[index] = 0;             // clear pointer for next event
    } else if (m_fakeCrackCells) { // can be true only for full-size container

      pCell = tileCellsP.nextElementPtr();
      const CaloDetDescrElement* dde = m_tileMgr->get_cell_element(index);
      pCell->set(dde, dde->identify());

      if (m_tileID->section(pCell->ID()) == TileID::GAPDET) { // missing D4/E3/E4 cell

        int ind = m_tileID->module(pCell->ID()) + ((m_tileID->side(pCell->ID()) > 0) ? 0 : 64);
        if (EBdrawerPresent[ind]) {
          ++nFake;
          if (m_tileID->sample(pCell->ID()) == TileID::SAMP_E) {
            pCell->setEnergy(0.0, 0.0, TileID::LOWGAIN, CaloGain::INVALIDGAIN); // reset energy completely, indicate problem putting low gain
            pCell->setQuality(0, TileCell::MASK_BADCH, 0); // reset quality flag for first pmt
            pCell->setQuality(0, TileCell::MASK_BADCH, 1); // reset quality flag for second pmt
          } else {
            pCell->setEnergy(0.0, 0.0, TileID::LOWGAIN, TileID::LOWGAIN); // reset energy completely, indicate problem putting low gain
            pCell->setQuality(0, 0, 0); // reset quality flag for first pmt
            pCell->setQuality(0, 0, 1); // reset quality flag for second pmt
          }
          pCell->setTime(0.0); // reset time completely

          ATH_MSG_VERBOSE ( "adding fake cell with id=" << m_tileID->to_string(pCell->ID(), -2)
                           << " ene=" << pCell->energy()
                           << " status=" << (pCell->badcell() ? "bad" : "good") );

          coll->push_back(pCell); // store cell in container
        }
      }
    }
  }

  if (msgLvl(MSG::DEBUG)) {
    msg(MSG::DEBUG) << " nChan=" << nChan
                    << " RawChSum=" << eCh
                    << " nCell=" << nCell
                    << " n2=" << nTwo
                    << " nFake=" << nFake
                    << " eneTot=" << eCellTot;

    if (m_MBTSCells)
      msg(MSG::DEBUG) << " nMBTS=" << nMBTS
                      << " eMBTS=" << eMBTSTot;
    if (m_E4prCells)
      msg(MSG::DEBUG) << " nE4pr=" << nE4pr
                      << " eE4pr=" << eE4prTot;

    msg(MSG::DEBUG) << endmsg;
  }
  
  m_tileID->set_do_checks(do_checks);
  // set back this flag to TileID
  m_tileTBID->set_do_checks(do_checks_tb);

}

